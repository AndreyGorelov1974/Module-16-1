/*Задание 1. Спидометр
Что нужно сделать
Реализуйте цифровой спидометр автомобиля. Сама модель автомобиля, которую нужно будет воссоздать, весьма проста.
Начальная скорость — 0 км/ч.
Пользователь вводит в стандартный ввод разницу (дельту) в скорости, и результирующая скорость показывается на спидометре в стандартный вывод.
Так происходит до той поры, пока машина снова не остановится,
то есть пока скорость не станет меньше или равна нулю (сравнение должно происходить с дельтой в 0,01).
Диапазон возможных значений скорости машины от 0 до 150 км/ч.
Сам показатель спидометра вместе с единицами измерения требуется записывать в отдельную строку-буфер,
которая потом и будет показываться на экране. Точность отображения скорости — до 0,1 км/ч.

Рекомендации
Используйте цикл do … while для организации постоянного опроса пользователя.
Для отображения числа с нужной точностью воспользуйтесь функцией std::sprintf(speed_str, "%.1f", speed_value);
где speed_str — строка, в которую функция sprintf «печатает» значение скорости (speed_value) с одним знаком после десятичной точки (%.1f).*/

#include <iostream>

//точность сравнения
const float epsilon = 0.01f;
//максимальнаяскорость машины
const float maxSpeed = 150.0f;

int main()
{
	//начальная скорость
	float currentSpeed = 0.0f;
	//изменение скорости
	float deltaSpeed = 0.0f;

	
	//основной цикл продолжается пока скорость не вернётсяк 0 с заданной точностью
	do {
		std::cout << "Current vehicle speed: " << currentSpeed << std::endl;
		//ввод изменения скорости
		std::cout << "Enter the vehicle speed change: ";
		std::cin >> deltaSpeed;
		currentSpeed += deltaSpeed;
		//машина не может разогнатьсябыстрее 150 км/ч
		if ((currentSpeed - maxSpeed) > epsilon) {
			currentSpeed = maxSpeed;			
		}
	
			//если элементов меньше sizeArray вставляем за последним значащим элементом
			
			//если больше вставляем в конец массива
			else  if (arr[sizeArray - 1] >= element) {
				arr[sizeArray - 1] = element;
				//инициализируем индекс для сортировки
				int indexSort = sizeArray - 1;
				//двигаемего к началу на своё место по порядку среди значащих элементов
				while ((indexSort > 0) && (arr[indexSort] < arr[indexSort - 1])) {
					std::swap(arr[indexSort], arr[indexSort - 1]);
					--indexSort;
				}
			}
		}
		//вывод отсортированного массива
		for (int i = 0; i < sizeArray; ++i)
		{
			std::cout << arr[i] << " ";
		}
		std::cout << std::endl;
		//ввод следующего элемента
		std::cout << "Input numbers: ";
	} while (currentSpeed > epsilon)
}